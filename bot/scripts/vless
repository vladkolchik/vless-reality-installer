#!/bin/bash

# vless CLI â€” manage Xray VLESS+Reality clients and quick diagnostics
# Commands:
#   vless add <name>
#   vless list
#   vless show <name|uuid>
#   vless del <name|uuid>
#   vless restart
#   vless doctor

set -Eeuo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

CONFIG_PATH="/usr/local/etc/xray/config.json"
OUTPUT_DIR="/root/vless-configs"

require_root() {
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    echo -e "${RED}[ERROR]${NC} This command must run as root (sudo)." >&2
    exit 1
  fi
}

require_file() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    echo -e "${RED}[ERROR]${NC} File not found: $path" >&2
    exit 1
  fi
}

require_dep() {
  local bin="$1"
  if ! command -v "$bin" >/dev/null 2>&1; then
    echo -e "${RED}[ERROR]${NC} Required dependency not found: $bin" >&2
    echo -e "${YELLOW}[HINT]${NC} Install: apt install -y $bin  or  yum/dnf install -y $bin" >&2
    exit 1
  fi
}

print_info() { echo -e "${GREEN}[INFO]${NC} $*"; }
print_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
print_err()  { echo -e "${RED}[ERROR]${NC} $*"; }

usage() {
  cat <<EOF
Usage: vless <command> [args]
Commands:
  add <name>          Add client with given name (stored in email field)
  list                List clients (uuid and name)
  show <name|uuid>    Show client URLs and write QR PNGs to ${OUTPUT_DIR}
  del <name|uuid>     Remove client from all VLESS inbounds
  restart             Restart xray service
  fix                 Fix Xray file permissions and restart service
  doctor              Quick diagnosis: ports, service, last logs
EOF
}

# Sanitize a string for filenames and tags
sanitize() {
  local s="$*"
  # Replace non [A-Za-z0-9._-] with _ and trim length to 50
  s="$(echo -n "$s" | sed -E 's/[^A-Za-z0-9._-]+/_/g' | cut -c1-50)"
  # Avoid empty
  if [[ -z "$s" ]]; then s="vpn_profile"; fi
  echo -n "$s"
}

# Read common Reality parameters from config
read_reality_params() {
  require_file "$CONFIG_PATH"
  require_dep jq
  # Choose first VLESS inbound (prefer port 443)
  local jq_base='.inbounds[] | select(.protocol=="vless")'
  PRIVATE_KEY=$(jq -r "${jq_base} | .streamSettings.realitySettings.privateKey" "$CONFIG_PATH" | head -n1)
  if [[ -z "$PRIVATE_KEY" || "$PRIVATE_KEY" == "null" ]]; then
    print_err "Could not read Reality privateKey from $CONFIG_PATH"
    exit 1
  fi
  # Derive public key from private
  require_dep xray
  local xout
  if xout=$(xray x25519 -i "$PRIVATE_KEY" 2>/dev/null); then
    PUBLIC_KEY=$(echo "$xout" | awk '/Public key:/ {print $3; exit}')
  fi
  if [[ -z "${PUBLIC_KEY:-}" ]]; then
    print_err "Failed to derive public key from private key"
    exit 1
  fi
  # Short ID: use first one
  SHORT_ID=$(jq -r "${jq_base} | .streamSettings.realitySettings.shortIds[0]" "$CONFIG_PATH" | head -n1)
  if [[ -z "$SHORT_ID" || "$SHORT_ID" == "null" ]]; then
    print_warn "No shortIds found; URLs will omit sid parameter"
    SHORT_ID=""
  fi
  # SNI / dest domain
  DEST_SITE=$(jq -r "(${jq_base} | .streamSettings.realitySettings.serverNames[0]) // (${jq_base} | .streamSettings.realitySettings.dest)" "$CONFIG_PATH" | head -n1)
  if [[ -z "$DEST_SITE" || "$DEST_SITE" == "null" ]]; then
    DEST_SITE="apple.com"
  fi
  # Normalize DEST_SITE if includes :port
  DEST_SITE=${DEST_SITE%%:*}
}

get_server_ip() {
  if SERVER_IP=$(curl -4 -fsS https://api.ipify.org); then
    :
  else
    SERVER_IP=$(hostname -I 2>/dev/null | awk '{print $1}')
  fi
  if [[ -z "${SERVER_IP:-}" ]]; then
    print_warn "Could not determine public IP automatically. Using local address."
    SERVER_IP="127.0.0.1"
  fi
}

list_clients() {
  require_file "$CONFIG_PATH"
  require_dep jq
  jq -r '
    def clients: [.inbounds[] | select(.protocol=="vless") | .settings.clients[]?] | unique_by(.id);
    clients | if length==0 then "No clients" else ("UUID                                  | NAME"), ("--------------------------------------|----------------"), (.[] | ( (.id // "-") + " | " + (.email // "-") )) end
  ' "$CONFIG_PATH"
}

add_client() {
  local name="$1"; shift || true
  if [[ -z "$name" ]]; then print_err "Name required"; exit 1; fi
  require_file "$CONFIG_PATH"
  require_dep jq
  local uuid
  if command -v uuidgen >/dev/null 2>&1; then
    uuid=$(uuidgen)
  else
    uuid=$(cat /proc/sys/kernel/random/uuid)
  fi
  local email="$name"
  # Update both VLESS inbounds
  local tmp
  tmp=$(mktemp)
  jq --arg uuid "$uuid" --arg email "$email" '
    (.inbounds[] | select(.protocol=="vless") | .settings.clients) |= (
      if any(.id == $uuid) then . else . + [{id:$uuid,flow:"xtls-rprx-vision",email:$email}] end
    )
  ' "$CONFIG_PATH" > "$tmp"
  mv "$tmp" "$CONFIG_PATH"
  print_info "Added client: $email ($uuid)"
  echo "$uuid"
}

remove_client() {
  local key="$1"; shift || true
  if [[ -z "$key" ]]; then print_err "Name or UUID required"; exit 1; fi
  require_file "$CONFIG_PATH"
  require_dep jq
  local tmp
  tmp=$(mktemp)
  jq --arg k "$key" '
    (.inbounds[] | select(.protocol=="vless") | .settings.clients) |= (
      map(select((.id != $k) and ((.email // "") != $k)))
    )
  ' "$CONFIG_PATH" > "$tmp"
  mv "$tmp" "$CONFIG_PATH"
  print_info "Removed client entries matching: $key"
}

show_client() {
  local key="$1"; shift || true
  if [[ -z "$key" ]]; then print_err "Name or UUID required"; exit 1; fi
  require_file "$CONFIG_PATH"
  require_dep jq
  read_reality_params
  get_server_ip

  # Find uuid and name (email)
  local uuid email
  readarray -t arr < <(jq -r --arg k "$key" '
    [.inbounds[] | select(.protocol=="vless") | .settings.clients[]?]
    | unique_by(.id)
    | map(select((.id==$k) or ((.email // "")==$k)))
    | if length>0 then [.[] | (.id//""), (.email//"")] else [] end | .[]
  ' "$CONFIG_PATH")
  if (( ${#arr[@]} >= 2 )); then
    uuid="${arr[0]}"; email="${arr[1]}"
  else
    print_err "Client not found: $key"
    exit 1
  fi

  local safe
  safe=$(sanitize "${email:-$uuid}")
  mkdir -p "$OUTPUT_DIR"

  # URLs
  local sid_q=""; if [[ -n "$SHORT_ID" ]]; then sid_q="&sid=$SHORT_ID"; fi
  local URL_443="vless://$uuid@$SERVER_IP:443?type=tcp&security=reality&pbk=$PUBLIC_KEY&fp=chrome&sni=$DEST_SITE${sid_q}&flow=xtls-rprx-vision#$safe"
  local URL_80="vless://$uuid@$SERVER_IP:80?type=tcp&security=reality&pbk=$PUBLIC_KEY&fp=safari&sni=$DEST_SITE${sid_q}&flow=xtls-rprx-vision#$safe"

  echo "443: $URL_443"
  echo "80:  $URL_80"

  # QR codes
  if command -v qrencode >/dev/null 2>&1; then
    qrencode -o "$OUTPUT_DIR/${safe}_443.png" "$URL_443"
    qrencode -o "$OUTPUT_DIR/${safe}_80.png"  "$URL_80"
    print_info "QR saved: $OUTPUT_DIR/${safe}_443.png, ${safe}_80.png"
  else
    print_warn "qrencode not installed; skipped QR generation"
  fi
}

fix_xray_permissions() {
  print_info "Fixing Xray configuration permissions..."
  
  # Fix config file permissions
  if [[ -f "$CONFIG_PATH" ]]; then
    chown root:root "$CONFIG_PATH" 2>/dev/null || true
    chmod 644 "$CONFIG_PATH" 2>/dev/null || true
    print_info "Fixed permissions for $CONFIG_PATH"
  fi
  
  # Fix directory permissions
  local config_dir="/usr/local/etc/xray"
  if [[ -d "$config_dir" ]]; then
    chown -R root:root "$config_dir" 2>/dev/null || true
    chmod 755 "$config_dir" 2>/dev/null || true
    find "$config_dir" -type f -name "*.json" -exec chmod 644 {} \; 2>/dev/null || true
    print_info "Fixed permissions for $config_dir"
  fi
  
  # Fix xray binary permissions
  if [[ -f "/usr/local/bin/xray" ]]; then
    chown root:root "/usr/local/bin/xray" 2>/dev/null || true
    chmod 755 "/usr/local/bin/xray" 2>/dev/null || true
    print_info "Fixed permissions for /usr/local/bin/xray"
  fi
}

restart_xray() {
  # First, fix permissions that might cause issues
  fix_xray_permissions
  
  # Try multiple possible service names
  for service_name in "xray" "xray.service"; do
    if systemctl list-unit-files 2>/dev/null | grep -q "^${service_name}"; then
      print_info "Restarting $service_name..."
      if systemctl restart "$service_name" 2>/dev/null; then
        sleep 3
        if systemctl is-active --quiet "$service_name"; then
          print_info "$service_name successfully restarted"
          return 0
        else
          print_err "$service_name restarted but not active"
          print_info "Service status:"
          systemctl status "$service_name" --no-pager -l | head -15 || true
          print_info "Recent logs:"
          journalctl -u "$service_name" -n 10 --no-pager | cat || true
          return 1
        fi
      else
        print_err "Failed to restart $service_name"
        systemctl status "$service_name" --no-pager -l | head -10 || true
        return 1
      fi
    fi
  done
  
  # If no service found, try to restart anyway (maybe it exists but not listed)
  print_warn "xray service not found in list, attempting restart anyway..."
  if systemctl restart xray 2>/dev/null; then
    sleep 3
    if systemctl is-active --quiet xray; then
      print_info "xray successfully restarted"
      return 0
    else
      print_err "xray restarted but not active"
      print_info "Service status:"
      systemctl status xray --no-pager -l | head -15 || true
      return 1
    fi
  else
    print_err "xray service not found or failed to restart"
    print_info "Available services with 'xray' in name:"
    systemctl list-unit-files 2>/dev/null | grep -i xray || echo "  (none found)"
    return 1
  fi
}

doctor() {
  echo -e "${BLUE}== Service Status ==${NC}"
  for service_name in "xray" "xray.service"; do
    if systemctl list-unit-files 2>/dev/null | grep -q "^${service_name}"; then
      echo "Service: $service_name"
      systemctl status "$service_name" --no-pager -l | head -15 || true
      break
    fi
  done
  
  echo -e "${BLUE}== Service List ==${NC}"
  systemctl list-unit-files 2>/dev/null | grep -i xray || echo "No xray services found"
  
  echo -e "${BLUE}== Last logs ==${NC}"
  journalctl -u xray -n 30 --no-pager | cat || true
  
  echo -e "${BLUE}== Configuration ==${NC}"
  if [[ -f "$CONFIG_PATH" ]]; then
    echo "Config file exists: $CONFIG_PATH"
    echo "Config size: $(wc -c < "$CONFIG_PATH" 2>/dev/null || echo "unknown") bytes"
    # Test config validity
    if command -v xray >/dev/null 2>&1; then
      echo "Config test:"
      xray -test -config "$CONFIG_PATH" 2>&1 | head -5 || echo "Config test failed"
    fi
  else
    echo "Config file missing: $CONFIG_PATH"
  fi
  
  echo -e "${BLUE}== Ports ==${NC}"
  ss -ltnp | grep -E ':443|:80' || echo "No services listening on ports 443/80"
  
  echo -e "${BLUE}== Public IP ==${NC}"
  curl -4 -fsS https://api.ipify.org || echo "(unavailable)"
}

main() {
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    add)
      require_root
      local name="${1:-}"; shift || true
      add_client "$name"
      ;;
    list)
      list_clients
      ;;
    show)
      local key="${1:-}"; shift || true
      read_reality_params
      show_client "$key"
      ;;
    del)
      require_root
      local key="${1:-}"; shift || true
      remove_client "$key"
      ;;
    restart)
      require_root
      restart_xray
      ;;
    fix)
      require_root
      fix_xray_permissions
      restart_xray
      ;;
    doctor)
      doctor
      ;;
    -h|--help|help|"")
      usage
      ;;
    *)
      print_err "Unknown command: $cmd"; usage; exit 1;
      ;;
  esac
}

main "$@"


