#!/bin/bash

# vless CLI — manage Xray VLESS+Reality clients and quick diagnostics
# Commands:
#   vless add <name>
#   vless list
#   vless show <name|uuid>
#   vless del <name|uuid>
#   vless restart
#   vless doctor

set -Eeuo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

CONFIG_PATH="/usr/local/etc/xray/config.json"
OUTPUT_DIR="/root/vless-configs"

require_root() {
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    echo -e "${RED}[ERROR]${NC} This command must run as root (sudo)." >&2
    exit 1
  fi
}

require_file() {
  local path="$1"
  if [[ ! -f "$path" ]]; then
    echo -e "${RED}[ERROR]${NC} File not found: $path" >&2
    exit 1
  fi
}

require_dep() {
  local bin="$1"
  if ! command -v "$bin" >/dev/null 2>&1; then
    echo -e "${RED}[ERROR]${NC} Required dependency not found: $bin" >&2
    echo -e "${YELLOW}[HINT]${NC} Install: apt install -y $bin  or  yum/dnf install -y $bin" >&2
    exit 1
  fi
}

print_info() { echo -e "${GREEN}[INFO]${NC} $*"; }
print_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
print_err()  { echo -e "${RED}[ERROR]${NC} $*"; }

usage() {
  cat <<EOF
Usage: vless <command> [args]
Commands:
  add <name>          Add client with given name (stored in email field)
  list                List clients (uuid and name)
  show <name|uuid>    Show client URLs and write QR PNGs to ${OUTPUT_DIR}
  del <name|uuid>     Remove client from all VLESS inbounds
  restart             Restart xray service
  fix                 Fix Xray file permissions and restart service
  block-torrents      Block torrent traffic (BitTorrent protocol and ports)
  unblock-torrents    Remove torrent blocking rules
  test                Test configuration reading and key availability
  doctor              Quick diagnosis: ports, service, last logs
EOF
}

# Sanitize a string for filenames and tags
sanitize() {
  local s="$*"
  # Replace non [A-Za-z0-9._-] with _ and trim length to 50
  s="$(echo -n "$s" | sed -E 's/[^A-Za-z0-9._-]+/_/g' | cut -c1-50)"
  # Avoid empty
  if [[ -z "$s" ]]; then s="vpn_profile"; fi
  echo -n "$s"
}

# Read common Reality parameters from config
read_reality_params() {
  require_file "$CONFIG_PATH"
  require_dep jq
  # Choose first VLESS inbound (prefer port 443)
  local jq_base='.inbounds[] | select(.protocol=="vless")'
  PRIVATE_KEY=$(jq -r "${jq_base} | .streamSettings.realitySettings.privateKey" "$CONFIG_PATH" | head -n1)
  if [[ -z "$PRIVATE_KEY" || "$PRIVATE_KEY" == "null" ]]; then
    print_err "Could not read Reality privateKey from $CONFIG_PATH"
    exit 1
  fi
  
  # Try to get public key from config first (preferred method)
  PUBLIC_KEY=$(jq -r "${jq_base} | .streamSettings.realitySettings.publicKey // empty" "$CONFIG_PATH" | head -n1)
  
  if [[ -n "$PUBLIC_KEY" && "$PUBLIC_KEY" != "null" ]]; then
    print_info "Using public key from configuration"
  else
    # If not in config, try to derive from private key
    require_dep xray
    local xout
    PUBLIC_KEY=""
    
    print_info "Public key not found in config, deriving from private key..."
    
    # Method 1: Try xray x25519 -i (input private key)
    if xout=$(xray x25519 -i "$PRIVATE_KEY" 2>/dev/null); then
      PUBLIC_KEY=$(echo "$xout" | grep -i "public" | sed -E 's/.*[Kk]ey:?\s*([A-Za-z0-9+/=_-]+).*/\1/' | head -1)
    fi
    
    # Method 2: If method 1 failed, try alternative parsing
    if [[ -z "$PUBLIC_KEY" ]]; then
      print_warn "Standard derivation failed, trying alternative parsing..."
      if xout=$(xray x25519 -i "$PRIVATE_KEY" 2>/dev/null); then
        PUBLIC_KEY=$(echo "$xout" | grep -oE '[A-Za-z0-9+/=_-]{32,}' | tail -1)
      fi
    fi
    
    # Method 3: Last resort - generate new pair to understand format
    if [[ -z "$PUBLIC_KEY" ]]; then
      print_warn "Alternative parsing failed, trying format detection..."
      if xout=$(xray x25519 2>/dev/null); then
        # This generates a new pair, but we can use it to understand the format
        local sample_public=$(echo "$xout" | grep -i "public" | sed -E 's/.*[Kk]ey:?\s*([A-Za-z0-9+/=_-]+).*/\1/' | head -1)
        
        if [[ -n "$sample_public" ]]; then
          # Now try again with our private key using the same parsing method
          if xout2=$(xray x25519 -i "$PRIVATE_KEY" 2>/dev/null); then
            PUBLIC_KEY=$(echo "$xout2" | sed -E 's/.*[Kk]ey:?\s*([A-Za-z0-9+/=_-]+).*/\1/' | tail -1)
          fi
        fi
      fi
    fi
    
    if [[ -z "$PUBLIC_KEY" ]]; then
      print_err "Failed to derive public key from private key"
      print_err "This might be due to changes in X-ray x25519 command format"
      print_err "Try running manually: xray x25519 -i \"$PRIVATE_KEY\""
      print_err "Or regenerate the server configuration to include publicKey"
      exit 1
    fi
  fi
  
  # Short ID: use first one
  SHORT_ID=$(jq -r "${jq_base} | .streamSettings.realitySettings.shortIds[0]" "$CONFIG_PATH" | head -n1)
  if [[ -z "$SHORT_ID" || "$SHORT_ID" == "null" ]]; then
    print_warn "No shortIds found; URLs will omit sid parameter"
    SHORT_ID=""
  fi
  # SNI / dest domain
  DEST_SITE=$(jq -r "(${jq_base} | .streamSettings.realitySettings.serverNames[0]) // (${jq_base} | .streamSettings.realitySettings.dest)" "$CONFIG_PATH" | head -n1)
  if [[ -z "$DEST_SITE" || "$DEST_SITE" == "null" ]]; then
    DEST_SITE="apple.com"
  fi
  # Normalize DEST_SITE if includes :port
  DEST_SITE=${DEST_SITE%%:*}
}

get_server_ip() {
  if SERVER_IP=$(curl -4 -fsS https://api.ipify.org); then
    :
  else
    SERVER_IP=$(hostname -I 2>/dev/null | awk '{print $1}')
  fi
  if [[ -z "${SERVER_IP:-}" ]]; then
    print_warn "Could not determine public IP automatically. Using local address."
    SERVER_IP="127.0.0.1"
  fi
}

list_clients() {
  require_file "$CONFIG_PATH"
  require_dep jq
  jq -r '
    def clients: [.inbounds[] | select(.protocol=="vless") | .settings.clients[]?] | unique_by(.id);
    clients | if length==0 then "No clients" else ("UUID                                  | NAME"), ("--------------------------------------|----------------"), (.[] | ( (.id // "-") + " | " + (.email // "-") )) end
  ' "$CONFIG_PATH"
}

add_client() {
  local name="$1"; shift || true
  if [[ -z "$name" ]]; then print_err "Name required"; exit 1; fi
  require_file "$CONFIG_PATH"
  require_dep jq
  local uuid
  if command -v uuidgen >/dev/null 2>&1; then
    uuid=$(uuidgen)
  else
    uuid=$(cat /proc/sys/kernel/random/uuid)
  fi
  local email="$name"
  # Update both VLESS inbounds
  local tmp
  tmp=$(mktemp)
  jq --arg uuid "$uuid" --arg email "$email" '
    (.inbounds[] | select(.protocol=="vless") | .settings.clients) |= (
      if any(.id == $uuid) then . else . + [{id:$uuid,flow:"xtls-rprx-vision",email:$email}] end
    )
  ' "$CONFIG_PATH" > "$tmp"
  mv "$tmp" "$CONFIG_PATH"
  print_info "Added client: $email ($uuid)"
  echo "$uuid"
}

remove_client() {
  local key="$1"; shift || true
  if [[ -z "$key" ]]; then print_err "Name or UUID required"; exit 1; fi
  require_file "$CONFIG_PATH"
  require_dep jq
  local tmp
  tmp=$(mktemp)
  jq --arg k "$key" '
    (.inbounds[] | select(.protocol=="vless") | .settings.clients) |= (
      map(select((.id != $k) and ((.email // "") != $k)))
    )
  ' "$CONFIG_PATH" > "$tmp"
  mv "$tmp" "$CONFIG_PATH"
  print_info "Removed client entries matching: $key"
}

show_client() {
  local key="$1"; shift || true
  if [[ -z "$key" ]]; then print_err "Name or UUID required"; exit 1; fi
  require_file "$CONFIG_PATH"
  require_dep jq
  read_reality_params
  get_server_ip

  # Find uuid and name (email)
  local uuid email
  readarray -t arr < <(jq -r --arg k "$key" '
    [.inbounds[] | select(.protocol=="vless") | .settings.clients[]?]
    | unique_by(.id)
    | map(select((.id==$k) or ((.email // "")==$k)))
    | if length>0 then [.[] | (.id//""), (.email//"")] else [] end | .[]
  ' "$CONFIG_PATH")
  if (( ${#arr[@]} >= 2 )); then
    uuid="${arr[0]}"; email="${arr[1]}"
  else
    print_err "Client not found: $key"
    exit 1
  fi

  local safe
  safe=$(sanitize "${email:-$uuid}")
  mkdir -p "$OUTPUT_DIR"

  # URLs
  local sid_q=""; if [[ -n "$SHORT_ID" ]]; then sid_q="&sid=$SHORT_ID"; fi
  local URL_443="vless://$uuid@$SERVER_IP:443?type=tcp&security=reality&pbk=$PUBLIC_KEY&fp=chrome&sni=$DEST_SITE${sid_q}&flow=xtls-rprx-vision#$safe"
  local URL_80="vless://$uuid@$SERVER_IP:80?type=tcp&security=reality&pbk=$PUBLIC_KEY&fp=safari&sni=$DEST_SITE${sid_q}&flow=xtls-rprx-vision#$safe"

  echo "443: $URL_443"
  echo "80:  $URL_80"

  # QR codes
  if command -v qrencode >/dev/null 2>&1; then
    qrencode -o "$OUTPUT_DIR/${safe}_443.png" "$URL_443"
    qrencode -o "$OUTPUT_DIR/${safe}_80.png"  "$URL_80"
    print_info "QR saved: $OUTPUT_DIR/${safe}_443.png, ${safe}_80.png"
  else
    print_warn "qrencode not installed; skipped QR generation"
  fi
}

fix_xray_permissions() {
  print_info "Fixing Xray configuration permissions..."
  
  # Fix config file permissions
  if [[ -f "$CONFIG_PATH" ]]; then
    chown root:root "$CONFIG_PATH" 2>/dev/null || true
    chmod 644 "$CONFIG_PATH" 2>/dev/null || true
    print_info "Fixed permissions for $CONFIG_PATH"
  fi
  
  # Fix directory permissions
  local config_dir="/usr/local/etc/xray"
  if [[ -d "$config_dir" ]]; then
    chown -R root:root "$config_dir" 2>/dev/null || true
    chmod 755 "$config_dir" 2>/dev/null || true
    find "$config_dir" -type f -name "*.json" -exec chmod 644 {} \; 2>/dev/null || true
    print_info "Fixed permissions for $config_dir"
  fi
  
  # Fix xray binary permissions
  if [[ -f "/usr/local/bin/xray" ]]; then
    chown root:root "/usr/local/bin/xray" 2>/dev/null || true
    chmod 755 "/usr/local/bin/xray" 2>/dev/null || true
    print_info "Fixed permissions for /usr/local/bin/xray"
  fi
}

restart_xray() {
  # First, fix permissions that might cause issues
  fix_xray_permissions
  
  # Try multiple possible service names
  for service_name in "xray" "xray.service"; do
    if systemctl list-unit-files 2>/dev/null | grep -q "^${service_name}"; then
      print_info "Restarting $service_name..."
      if systemctl restart "$service_name" 2>/dev/null; then
        sleep 3
        if systemctl is-active --quiet "$service_name"; then
          print_info "$service_name successfully restarted"
          return 0
        else
          print_err "$service_name restarted but not active"
          print_info "Service status:"
          systemctl status "$service_name" --no-pager -l | head -15 || true
          print_info "Recent logs:"
          journalctl -u "$service_name" -n 10 --no-pager | cat || true
          return 1
        fi
      else
        print_err "Failed to restart $service_name"
        systemctl status "$service_name" --no-pager -l | head -10 || true
        return 1
      fi
    fi
  done
  
  # If no service found, try to restart anyway (maybe it exists but not listed)
  print_warn "xray service not found in list, attempting restart anyway..."
  if systemctl restart xray 2>/dev/null; then
    sleep 3
    if systemctl is-active --quiet xray; then
      print_info "xray successfully restarted"
      return 0
    else
      print_err "xray restarted but not active"
      print_info "Service status:"
      systemctl status xray --no-pager -l | head -15 || true
      return 1
    fi
  else
    print_err "xray service not found or failed to restart"
    print_info "Available services with 'xray' in name:"
    systemctl list-unit-files 2>/dev/null | grep -i xray || echo "  (none found)"
    return 1
  fi
}

doctor() {
  echo -e "${BLUE}== Service Status ==${NC}"
  for service_name in "xray" "xray.service"; do
    if systemctl list-unit-files 2>/dev/null | grep -q "^${service_name}"; then
      echo "Service: $service_name"
      systemctl status "$service_name" --no-pager -l | head -15 || true
      break
    fi
  done
  
  echo -e "${BLUE}== Service List ==${NC}"
  systemctl list-unit-files 2>/dev/null | grep -i xray || echo "No xray services found"
  
  echo -e "${BLUE}== Last logs ==${NC}"
  journalctl -u xray -n 30 --no-pager | cat || true
  
  echo -e "${BLUE}== Configuration ==${NC}"
  if [[ -f "$CONFIG_PATH" ]]; then
    echo "Config file exists: $CONFIG_PATH"
    echo "Config size: $(wc -c < "$CONFIG_PATH" 2>/dev/null || echo "unknown") bytes"
    # Test config validity
    if command -v xray >/dev/null 2>&1; then
      echo "Config test:"
      xray -test -config "$CONFIG_PATH" 2>&1 | head -5 || echo "Config test failed"
    fi
  else
    echo "Config file missing: $CONFIG_PATH"
  fi
  
  echo -e "${BLUE}== Ports ==${NC}"
  ss -ltnp | grep -E ':443|:80' || echo "No services listening on ports 443/80"
  
  echo -e "${BLUE}== Public IP ==${NC}"
  curl -4 -fsS https://api.ipify.org || echo "(unavailable)"
}

# Block torrent traffic by updating Xray config
block_torrents() {
  print_info "Adding torrent blocking rules to Xray configuration..."
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    print_err "Configuration file not found: $CONFIG_PATH"
    return 1
  fi
  
  # Create backup
  local backup_path="${CONFIG_PATH}.backup.$(date +%Y%m%d_%H%M%S)"
  cp "$CONFIG_PATH" "$backup_path"
  print_info "Backup created: $backup_path"
  
  # Check if blocking already exists
  if jq -e '.routing.rules[]? | select(.outboundTag == "block")' "$CONFIG_PATH" >/dev/null 2>&1; then
    print_warn "Torrent blocking rules already exist"
    return 0
  fi
  
  # Create temporary file for updated config
  local temp_config
  temp_config=$(mktemp)
  
  # Use a simple approach: create the complete configuration in steps
  # Step 1: Add blackhole outbound if not exists
  jq 'if (.outbounds | map(select(.tag == "block")) | length) == 0 then .outbounds += [{"protocol": "blackhole", "tag": "block"}] else . end' "$CONFIG_PATH" > "${temp_config}.step1"
  
  # Step 2: Initialize routing section if it doesn't exist
  jq 'if .routing then . else .routing = {} end' "${temp_config}.step1" > "${temp_config}.step2"
  
  # Step 3: Add torrent blocking rules (simple assignment without concatenation)
  jq '.routing.rules = [
    {"type": "field", "protocol": ["bittorrent"], "outboundTag": "block"},
    {"type": "field", "port": "6881-6889", "outboundTag": "block"},
    {"type": "field", "port": "51413", "outboundTag": "block"},
    {"type": "field", "domain": ["tracker", "torrent", "thepiratebay", "1337x", "rarbg", "kickass", "rutracker", "nnmclub"], "outboundTag": "block"},
    {"type": "field", "network": "udp", "port": "1337,6969,8080,2710", "outboundTag": "block"}
  ]' "${temp_config}.step2" > "$temp_config"
  
  # Clean up intermediate files
  rm -f "${temp_config}.step1" "${temp_config}.step2"
  
  # Validate JSON
  if jq empty "$temp_config" 2>/dev/null; then
    mv "$temp_config" "$CONFIG_PATH"
    print_info "Configuration updated successfully"
  else
    print_err "Invalid JSON generated. Restoring backup..."
    cp "$backup_path" "$CONFIG_PATH"
    rm -f "$temp_config"
    return 1
  fi
  
  # Test config with xray
  if command -v xray >/dev/null 2>&1; then
    if ! xray -test -config "$CONFIG_PATH" 2>/dev/null; then
      print_err "Configuration test failed. Restoring backup..."
      cp "$backup_path" "$CONFIG_PATH"
      return 1
    fi
  fi
  
  # Restart xray
  print_info "Restarting Xray service..."
  if restart_xray; then
    print_info "✅ Torrent blocking enabled successfully!"
    print_info "🚫 Blocked: BitTorrent protocol, ports 6881-6889, 51413, UDP 1337,6969,8080,2710"
    print_info "🚫 Blocked domains: tracker, torrent, popular torrent sites"
  else
    print_err "Failed to restart Xray. Restoring backup..."
    cp "$backup_path" "$CONFIG_PATH"
    restart_xray
    return 1
  fi
}

# Remove torrent blocking rules
unblock_torrents() {
  print_info "Removing torrent blocking rules from Xray configuration..."
  
  if [[ ! -f "$CONFIG_PATH" ]]; then
    print_err "Configuration file not found: $CONFIG_PATH"
    return 1
  fi
  
  # Create backup
  local backup_path="${CONFIG_PATH}.backup.$(date +%Y%m%d_%H%M%S)"
  cp "$CONFIG_PATH" "$backup_path"
  print_info "Backup created: $backup_path"
  
  # Check if blocking exists
  if ! jq -e '.routing.rules[]? | select(.outboundTag == "block")' "$CONFIG_PATH" >/dev/null 2>&1; then
    print_warn "No torrent blocking rules found"
    return 0
  fi
  
  # Create temporary file for updated config
  local temp_config
  temp_config=$(mktemp)
  
  # Remove blocking rules and blackhole outbound using jq
  # Step 1: Remove blackhole outbound
  jq '.outbounds = (.outbounds | map(select(.tag != "block")))' "$CONFIG_PATH" > "${temp_config}.step1"
  
  # Step 2: Remove routing rules with "block" outboundTag
  jq 'if .routing.rules then .routing.rules = (.routing.rules | map(select(.outboundTag != "block"))) else . end' "${temp_config}.step1" > "${temp_config}.step2"
  
  # Step 3: Remove routing section if no rules left
  jq 'if .routing.rules and (.routing.rules | length) == 0 then del(.routing) else . end' "${temp_config}.step2" > "$temp_config"
  
  # Clean up intermediate files
  rm -f "${temp_config}.step1" "${temp_config}.step2"
  
  # Validate JSON
  if jq empty "$temp_config" 2>/dev/null; then
    mv "$temp_config" "$CONFIG_PATH"
    print_info "Configuration updated successfully"
  else
    print_err "Invalid JSON generated. Restoring backup..."
    cp "$backup_path" "$CONFIG_PATH"
    rm -f "$temp_config"
    return 1
  fi
  
  # Test config with xray
  if command -v xray >/dev/null 2>&1; then
    if ! xray -test -config "$CONFIG_PATH" 2>/dev/null; then
      print_err "Configuration test failed. Restoring backup..."
      cp "$backup_path" "$CONFIG_PATH"
      return 1
    fi
  fi
  
  # Restart xray
  print_info "Restarting Xray service..."
  if restart_xray; then
    print_info "✅ Torrent blocking removed successfully!"
    print_info "🌐 All traffic is now allowed through the VPN"
  else
    print_err "Failed to restart Xray. Restoring backup..."
    cp "$backup_path" "$CONFIG_PATH"
    restart_xray
    return 1
  fi
}

main() {
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    add)
      require_root
      local name="${1:-}"; shift || true
      add_client "$name"
      ;;
    list)
      list_clients
      ;;
    show)
      local key="${1:-}"; shift || true
      show_client "$key"
      ;;
    del)
      require_root
      local key="${1:-}"; shift || true
      remove_client "$key"
      ;;
    restart)
      require_root
      restart_xray
      ;;
    fix)
      require_root
      fix_xray_permissions
      restart_xray
      ;;
    block-torrents)
      require_root
      block_torrents
      ;;
    unblock-torrents)
      require_root
      unblock_torrents
      ;;
    doctor)
      doctor
      ;;
    test)
      # Test configuration reading without requiring root
      print_info "Testing configuration reading..."
      if [[ -f "$CONFIG_PATH" ]]; then
        print_info "Config file exists: $CONFIG_PATH"
        if command -v jq >/dev/null 2>&1; then
          local private_key=$(jq -r '.inbounds[] | select(.protocol=="vless") | .streamSettings.realitySettings.privateKey' "$CONFIG_PATH" | head -n1)
          local public_key=$(jq -r '.inbounds[] | select(.protocol=="vless") | .streamSettings.realitySettings.publicKey // empty' "$CONFIG_PATH" | head -n1)
          print_info "Private key found: ${private_key:+YES}"
          print_info "Public key found: ${public_key:+YES}"
          if [[ -n "$public_key" && "$public_key" != "null" ]]; then
            print_info "✅ Configuration appears ready for client generation"
          else
            print_warn "⚠️  Public key missing from config, will try to derive"
          fi
        else
          print_err "jq not available for config testing"
        fi
      else
        print_err "Config file not found: $CONFIG_PATH"
      fi
      ;;
    -h|--help|help|"")
      usage
      ;;
    *)
      print_err "Unknown command: $cmd"; usage; exit 1;
      ;;
  esac
}

main "$@"


